{"version":3,"file":"talk-JitsiEncryptionWorker.worker.worker.js?v=c072f73c847b88fc108d","mappings":"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","sources":["webpack:///talk/src/utils/e2ee/crypto-utils.js","webpack:///talk/src/utils/e2ee/JitsiEncryptionWorkerContext.js","webpack:///talk/src/utils/e2ee/JitsiEncryptionWorker.worker.js"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n/**\n * Derives a set of keys from the master key.\n * @param {CryptoKey} material - master key to derive from\n *\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nexport async function deriveKeys(material) {\n    const info = new ArrayBuffer();\n    const textEncoder = new TextEncoder();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n    const encryptionKey = await crypto.subtle.deriveKey({\n        name: 'HKDF',\n        salt: textEncoder.encode('TalkFrameEncryptionKey'),\n        hash: 'SHA-256',\n        info\n    }, material, {\n        name: 'AES-GCM',\n        length: 128\n    }, false, [ 'encrypt', 'decrypt' ]);\n\n    return {\n        material,\n        encryptionKey\n    };\n}\n\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n * @param {CryptoKey} material - base key material\n * @returns {Promise<ArrayBuffer>} - ratcheted key material\n */\nexport async function ratchet(material) {\n    const textEncoder = new TextEncoder();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n    return crypto.subtle.deriveBits({\n        name: 'HKDF',\n        salt: textEncoder.encode('TalkFrameRatchetKey'),\n        hash: 'SHA-256',\n        info: new ArrayBuffer()\n    }, material, 256);\n}\n\n/**\n * Converts a raw key into a WebCrypto key object with default options\n * suitable for our usage.\n * @param {ArrayBuffer} keyBytes - raw key\n * @param {Array} keyUsages - key usages, see importKey documentation\n * @returns {Promise<CryptoKey>} - the WebCrypto key.\n */\nexport async function importKey(keyBytes) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n    return crypto.subtle.importKey('raw', keyBytes, 'HKDF', false, [ 'deriveBits', 'deriveKey' ]);\n}\n","/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n/* eslint-disable no-bitwise */\n/* global BigInt */\n\nimport { deriveKeys, importKey, ratchet } from './crypto-utils';\n\n// We use a ringbuffer of keys so we can change them and still decode packets that were\n// encrypted with an old key. We use a size of 16 which corresponds to the four bits\n// in the frame trailer.\nconst KEYRING_SIZE = 16;\n\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nconst UNENCRYPTED_BYTES = {\n    key: 10,\n    delta: 3,\n    undefined: 1 // frame.type is not set on audio\n};\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n\n/* We use a 96 bit IV for AES GCM. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams */\nconst IV_LENGTH = 12;\n\nconst RATCHET_WINDOW_SIZE = 8;\n\n/**\n * Per-participant context holding the cryptographic keys and\n * encode/decode functions\n */\nexport class Context {\n    /**\n     * @param {Object} options\n     */\n    constructor({ sharedKey = false } = {}) {\n        // An array (ring) of keys that we use for sending and receiving.\n        this._cryptoKeyRing = new Array(KEYRING_SIZE);\n\n        // A pointer to the currently used key.\n        this._currentKeyIndex = -1;\n\n        this._sendCounts = new Map();\n\n        this._sharedKey = sharedKey;\n    }\n\n    /**\n     * Derives the different subkeys and starts using them for encryption or\n     * decryption.\n     * @param {Uint8Array|false} key bytes. Pass false to disable.\n     * @param {Number} keyIndex\n     */\n    async setKey(key, keyIndex = -1) {\n        let newKey = false;\n\n        if (key) {\n            if (this._sharedKey) {\n                newKey = key;\n            } else {\n                const material = await importKey(key);\n\n                newKey = await deriveKeys(material);\n            }\n        }\n\n        this._setKeys(newKey, keyIndex);\n    }\n\n    /**\n     * Sets a set of keys and resets the sendCount.\n     * decryption.\n     * @param {Object} keys set of keys.\n     * @param {Number} keyIndex optional\n     * @private\n     */\n    _setKeys(keys, keyIndex = -1) {\n        if (keyIndex >= 0) {\n            this._currentKeyIndex = keyIndex % this._cryptoKeyRing.length;\n        }\n\n        this._cryptoKeyRing[this._currentKeyIndex] = keys;\n\n        this._sendCount = BigInt(0); // eslint-disable-line new-cap\n    }\n\n    /**\n     * Function that will be injected in a stream and will encrypt the given encoded frames.\n     *\n     * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n     * @param {TransformStreamDefaultController} controller - TransportStreamController.\n     *\n     * The VP8 payload descriptor described in\n     * https://tools.ietf.org/html/rfc7741#section-4.2\n     * is part of the RTP packet and not part of the frame and is not controllable by us.\n     * This is fine as the SFU keeps having access to it for routing.\n     *\n     * The encrypted frame is formed as follows:\n     * 1) Leave the first (10, 3, 1) bytes unencrypted, depending on the frame type and kind.\n     * 2) Form the GCM IV for the frame as described above.\n     * 3) Encrypt the rest of the frame using AES-GCM.\n     * 4) Allocate space for the encrypted frame.\n     * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n     * 6) Append the ciphertext to the encrypted frame.\n     * 7) Append the IV.\n     * 8) Append a single byte for the key identifier.\n     * 9) Enqueue the encrypted frame for sending.\n     */\n    encodeFunction(encodedFrame, controller) {\n        const keyIndex = this._currentKeyIndex;\n\n        if (this._cryptoKeyRing[keyIndex]) {\n            const iv = this._makeIV(encodedFrame.getMetadata().synchronizationSource, encodedFrame.timestamp);\n\n            // Thіs is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n            const frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type]);\n\n            // Frame trailer contains the R|IV_LENGTH and key index\n            const frameTrailer = new Uint8Array(2);\n\n            frameTrailer[0] = IV_LENGTH;\n            frameTrailer[1] = keyIndex;\n\n            // Construct frame trailer. Similar to the frame header described in\n            // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n            // but we put it at the end.\n            //\n            // ---------+-------------------------+-+---------+----\n            // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n            // ---------+-------------------------+-+---------+----\n\n            return crypto.subtle.encrypt({\n                name: ENCRYPTION_ALGORITHM,\n                iv,\n                additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n            }, this._cryptoKeyRing[keyIndex].encryptionKey, new Uint8Array(encodedFrame.data,\n                UNENCRYPTED_BYTES[encodedFrame.type]))\n            .then(cipherText => {\n                const newData = new ArrayBuffer(frameHeader.byteLength + cipherText.byteLength\n                    + iv.byteLength + frameTrailer.byteLength);\n                const newUint8 = new Uint8Array(newData);\n\n                newUint8.set(frameHeader); // copy first bytes.\n                newUint8.set(\n                    new Uint8Array(cipherText), frameHeader.byteLength); // add ciphertext.\n                newUint8.set(\n                    new Uint8Array(iv), frameHeader.byteLength + cipherText.byteLength); // append IV.\n                newUint8.set(\n                        frameTrailer,\n                        frameHeader.byteLength + cipherText.byteLength + iv.byteLength); // append frame trailer.\n\n                encodedFrame.data = newData;\n\n                return controller.enqueue(encodedFrame);\n            }, e => {\n                // TODO: surface this to the app.\n                console.error(e);\n\n                // We are not enqueuing the frame here on purpose.\n            });\n        }\n\n        /* NOTE WELL:\n         * This will send unencrypted data (only protected by DTLS transport encryption) when no key is configured.\n         * This is ok for demo purposes but should not be done once this becomes more relied upon.\n         */\n        controller.enqueue(encodedFrame);\n    }\n\n    /**\n     * Function that will be injected in a stream and will decrypt the given encoded frames.\n     *\n     * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n     * @param {TransformStreamDefaultController} controller - TransportStreamController.\n     */\n    async decodeFunction(encodedFrame, controller) {\n        const data = new Uint8Array(encodedFrame.data);\n        const keyIndex = data[encodedFrame.data.byteLength - 1];\n\n        if (this._cryptoKeyRing[keyIndex]) {\n\n            const decodedFrame = await this._decryptFrame(\n                encodedFrame,\n                keyIndex);\n\n            if (decodedFrame) {\n                controller.enqueue(decodedFrame);\n            }\n        }\n    }\n\n    /**\n     * Function that will decrypt the given encoded frame. If the decryption fails, it will\n     * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n     *\n     * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n     * @param {number} keyIndex - the index of the decryption data in _cryptoKeyRing array.\n     * @param {number} ratchetCount - the number of retries after ratcheting the key.\n     * @returns {Promise<RTCEncodedVideoFrame|RTCEncodedAudioFrame>} - The decrypted frame.\n     * @private\n     */\n    async _decryptFrame(\n            encodedFrame,\n            keyIndex,\n            initialKey = undefined,\n            ratchetCount = 0) {\n\n        const { encryptionKey } = this._cryptoKeyRing[keyIndex];\n        let { material } = this._cryptoKeyRing[keyIndex];\n\n        // Construct frame trailer. Similar to the frame header described in\n        // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n        // but we put it at the end.\n        //\n        // ---------+-------------------------+-+---------+----\n        // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n        // ---------+-------------------------+-+---------+----\n\n        try {\n            const frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type]);\n            const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n\n            const ivLength = frameTrailer[0];\n            const iv = new Uint8Array(\n                encodedFrame.data,\n                encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n                ivLength);\n\n            const cipherTextStart = frameHeader.byteLength;\n            const cipherTextLength = encodedFrame.data.byteLength\n                    - (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n\n            const plainText = await crypto.subtle.decrypt({\n                name: 'AES-GCM',\n                iv,\n                additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n            },\n                encryptionKey,\n                new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength));\n\n            const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n            const newUint8 = new Uint8Array(newData);\n\n            newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n            newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n\n            encodedFrame.data = newData;\n\n            return encodedFrame;\n        } catch (error) {\n            if (this._sharedKey) {\n                return;\n            }\n\n            if (ratchetCount < RATCHET_WINDOW_SIZE) {\n                const currentKey = this._cryptoKeyRing[this._currentKeyIndex];\n\n                material = await importKey(await ratchet(material));\n\n                const newKey = await deriveKeys(material);\n\n                this._setKeys(newKey);\n\n                return await this._decryptFrame(\n                    encodedFrame,\n                    keyIndex,\n                    initialKey || currentKey,\n                    ratchetCount + 1);\n            }\n\n            /**\n             * Since the key it is first send and only afterwards actually used for encrypting, there were\n             * situations when the decrypting failed due to the fact that the received frame was not encrypted\n             * yet and ratcheting, of course, did not solve the problem. So if we fail RATCHET_WINDOW_SIZE times,\n             * we come back to the initial key.\n             */\n            this._setKeys(initialKey);\n\n            // TODO: notify the application about error status.\n        }\n    }\n\n\n    /**\n     * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n     * https://tools.ietf.org/html/rfc7714#section-8.1\n     * It concatenates\n     * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n     * - the 32 bit rtp timestamp given on the encoded frame,\n     * - a send counter that is specific to the SSRC. Starts at a random number.\n     * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n     * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n     * randomly generated and SFUs may not rewrite this is considered acceptable.\n     * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n     *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n     * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n     * opus audio) every second. For video it rolls over roughly every 13 hours.\n     * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n     * every second. It will take a long time to roll over.\n     *\n     * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n     */\n    _makeIV(synchronizationSource, timestamp) {\n        const iv = new ArrayBuffer(IV_LENGTH);\n        const ivView = new DataView(iv);\n\n        // having to keep our own send count (similar to a picture id) is not ideal.\n        if (!this._sendCounts.has(synchronizationSource)) {\n            // Initialize with a random offset, similar to the RTP sequence number.\n            this._sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xFFFF));\n        }\n\n        const sendCount = this._sendCounts.get(synchronizationSource);\n\n        ivView.setUint32(0, synchronizationSource);\n        ivView.setUint32(4, timestamp);\n        ivView.setUint32(8, sendCount % 0xFFFF);\n\n        this._sendCounts.set(synchronizationSource, sendCount + 1);\n\n        return iv;\n    }\n}\n","/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n/* global TransformStream */\n/* eslint-disable no-bitwise */\n\n// Worker for E2EE/Insertable streams.\n\nimport { Context } from './JitsiEncryptionWorkerContext.js';\n\nconst contexts = new Map(); // Map participant id => context\n\nlet sharedContext;\n\n/**\n * Retrieves the participant {@code Context}, creating it if necessary.\n *\n * @param {string} participantId - The participant whose context we need.\n * @returns {Object} The context.\n */\nfunction getParticipantContext(participantId) {\n    if (sharedContext) {\n        return sharedContext;\n    }\n\n    if (!contexts.has(participantId)) {\n        contexts.set(participantId, new Context());\n    }\n\n    return contexts.get(participantId);\n}\n\n/**\n * Sets an encode / decode transform.\n *\n * @param {Object} context - The participant context where the transform will be applied.\n * @param {string} operation - Encode / decode.\n * @param {Object} readableStream - Readable stream part.\n * @param {Object} writableStream - Writable stream part.\n */\nfunction handleTransform(context, operation, readableStream, writableStream) {\n    if (operation === 'encode' || operation === 'decode') {\n        const transformFn = operation === 'encode' ? context.encodeFunction : context.decodeFunction;\n        const transformStream = new TransformStream({\n            transform: transformFn.bind(context)\n        });\n\n        readableStream\n            .pipeThrough(transformStream)\n            .pipeTo(writableStream);\n    } else {\n        console.error(`Invalid operation: ${operation}`);\n    }\n}\n\nonmessage = async event => {\n    const { operation } = event.data;\n\n    if (operation === 'initialize') {\n        const { sharedKey } = event.data;\n\n        if (sharedKey) {\n            sharedContext = new Context({ sharedKey });\n        }\n    } else if (operation === 'encode' || operation === 'decode') {\n        const { readableStream, writableStream, participantId } = event.data;\n        const context = getParticipantContext(participantId);\n\n        handleTransform(context, operation, readableStream, writableStream);\n    } else if (operation === 'setKey') {\n        const { participantId, key, keyIndex } = event.data;\n        const context = getParticipantContext(participantId);\n\n        if (key) {\n            context.setKey(key, keyIndex);\n        } else {\n            context.setKey(false, keyIndex);\n        }\n    } else if (operation === 'cleanup') {\n        const { participantId } = event.data;\n\n        contexts.delete(participantId);\n    } else if (operation === 'cleanupAll') {\n        contexts.clear();\n    } else {\n        console.error('e2ee worker', operation);\n    }\n};\n\n// Operations using RTCRtpScriptTransform.\nif (self.RTCTransformEvent) {\n    self.onrtctransform = event => {\n        const transformer = event.transformer;\n        const { operation, participantId } = transformer.options;\n        const context = getParticipantContext(participantId);\n\n        handleTransform(context, operation, transformer.readable, transformer.writable);\n    };\n}\n"],"names":["deriveKeys","material","info","textEncoder","encryptionKey","ratchet","importKey","keyBytes","KEYRING_SIZE","UNENCRYPTED_BYTES","ENCRYPTION_ALGORITHM","IV_LENGTH","RATCHET_WINDOW_SIZE","Context","sharedKey","key","keyIndex","newKey","keys","encodedFrame","controller","iv","frameHeader","frameTrailer","cipherText","newData","newUint8","e","decodedFrame","initialKey","ratchetCount","ivLength","cipherTextStart","cipherTextLength","plainText","currentKey","synchronizationSource","timestamp","ivView","sendCount","contexts","sharedContext","getParticipantContext","participantId","handleTransform","context","operation","readableStream","writableStream","transformFn","transformStream","event","transformer"],"sourceRoot":""}