(()=>{(()=>{"use strict";async function w(a){const t=new ArrayBuffer,e=new TextEncoder,n=await crypto.subtle.deriveKey({name:"HKDF",salt:e.encode("TalkFrameEncryptionKey"),hash:"SHA-256",info:t},a,{name:"AES-GCM",length:128},!1,["encrypt","decrypt"]);return{material:a,encryptionKey:n}}async function L(a){const t=new TextEncoder;return crypto.subtle.deriveBits({name:"HKDF",salt:t.encode("TalkFrameRatchetKey"),hash:"SHA-256",info:new ArrayBuffer},a,256)}async function d(a){return crypto.subtle.importKey("raw",a,"HKDF",!1,["deriveBits","deriveKey"])}const U=16,f={key:10,delta:3,undefined:1},T="AES-GCM",p=12,E=8;class g{constructor({sharedKey:t=!1}={}){this._cryptoKeyRing=new Array(U),this._currentKeyIndex=-1,this._sendCounts=new Map,this._sharedKey=t}async setKey(t,e=-1){let n=!1;if(t)if(this._sharedKey)n=t;else{const s=await d(t);n=await w(s)}this._setKeys(n,e)}_setKeys(t,e=-1){e>=0&&(this._currentKeyIndex=e%this._cryptoKeyRing.length),this._cryptoKeyRing[this._currentKeyIndex]=t,this._sendCount=BigInt(0)}encodeFunction(t,e){const n=this._currentKeyIndex;if(this._cryptoKeyRing[n]){const s=this._makeIV(t.getMetadata().synchronizationSource,t.timestamp),r=new Uint8Array(t.data,0,f[t.type]),o=new Uint8Array(2);return o[0]=p,o[1]=n,crypto.subtle.encrypt({name:T,iv:s,additionalData:new Uint8Array(t.data,0,r.byteLength)},this._cryptoKeyRing[n].encryptionKey,new Uint8Array(t.data,f[t.type])).then(i=>{const c=new ArrayBuffer(r.byteLength+i.byteLength+s.byteLength+o.byteLength),y=new Uint8Array(c);return y.set(r),y.set(new Uint8Array(i),r.byteLength),y.set(new Uint8Array(s),r.byteLength+i.byteLength),y.set(o,r.byteLength+i.byteLength+s.byteLength),t.data=c,e.enqueue(t)},i=>{console.error(i)})}e.enqueue(t)}async decodeFunction(t,e){const s=new Uint8Array(t.data)[t.data.byteLength-1];if(this._cryptoKeyRing[s]){const r=await this._decryptFrame(t,s);r&&e.enqueue(r)}}async _decryptFrame(t,e,n=void 0,s=0){const{encryptionKey:r}=this._cryptoKeyRing[e];let{material:o}=this._cryptoKeyRing[e];try{const i=new Uint8Array(t.data,0,f[t.type]),c=new Uint8Array(t.data,t.data.byteLength-2,2),y=c[0],I=new Uint8Array(t.data,t.data.byteLength-y-c.byteLength,y),C=i.byteLength,R=t.data.byteLength-(i.byteLength+y+c.byteLength),_=await crypto.subtle.decrypt({name:"AES-GCM",iv:I,additionalData:new Uint8Array(t.data,0,i.byteLength)},r,new Uint8Array(t.data,C,R)),b=new ArrayBuffer(i.byteLength+_.byteLength),A=new Uint8Array(b);return A.set(new Uint8Array(t.data,0,i.byteLength)),A.set(new Uint8Array(_),i.byteLength),t.data=b,t}catch{if(this._sharedKey)return;if(s<E){const c=this._cryptoKeyRing[this._currentKeyIndex];o=await d(await L(o));const y=await w(o);return this._setKeys(y),await this._decryptFrame(t,e,n||c,s+1)}this._setKeys(n)}}_makeIV(t,e){const n=new ArrayBuffer(p),s=new DataView(n);this._sendCounts.has(t)||this._sendCounts.set(t,Math.floor(Math.random()*65535));const r=this._sendCounts.get(t);return s.setUint32(0,t),s.setUint32(4,e),s.setUint32(8,r%65535),this._sendCounts.set(t,r+1),n}}const h=new Map;let l;function u(a){return l||(h.has(a)||h.set(a,new g),h.get(a))}function K(a,t,e,n){if(t==="encode"||t==="decode"){const s=t==="encode"?a.encodeFunction:a.decodeFunction,r=new TransformStream({transform:s.bind(a)});e.pipeThrough(r).pipeTo(n)}else console.error(`Invalid operation: ${t}`)}onmessage=async a=>{const{operation:t}=a.data;if(t==="initialize"){const{sharedKey:e}=a.data;e&&(l=new g({sharedKey:e}))}else if(t==="encode"||t==="decode"){const{readableStream:e,writableStream:n,participantId:s}=a.data,r=u(s);K(r,t,e,n)}else if(t==="setKey"){const{participantId:e,key:n,keyIndex:s}=a.data,r=u(e);n?r.setKey(n,s):r.setKey(!1,s)}else if(t==="cleanup"){const{participantId:e}=a.data;h.delete(e)}else t==="cleanupAll"?h.clear():console.error("e2ee worker",t)},self.RTCTransformEvent&&(self.onrtctransform=a=>{const t=a.transformer,{operation:e,participantId:n}=t.options,s=u(n);K(s,e,t.readable,t.writable)})})();})();

//# sourceMappingURL=talk-JitsiEncryptionWorker.worker.worker.js.map?v=c072f73c847b88fc108d